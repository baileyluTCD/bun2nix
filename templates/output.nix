# This file was autogenerated by `bun2nix`, editing it is not recommended.
# Consume it with `callPackage` in your actual derivation -> https://nixos-and-flakes.thiscute.world/nixpkgs/callpackage
{
  lib,
  fetchurl,
  runCommand,
  gnutar,
  bun,
  makeWrapper,
  ...
}: let
  # Set of Bun packages to install
  packages = {
    {%- for pkg in packages %}
    "{{ pkg.name }}" = {
      out_path = "{{ pkg.data.out_path }}";
      binaries = {
        {%- for binary in pkg.data.binaries %}
        "{{ binary.name }}" = "{{ binary.location }}";
        {%- endfor %}
      };
      pkg = fetchurl {
        name = "{{ pkg.npm_identifier }}";
        url = "{{ pkg.data.url }}";
        hash = "{{ pkg.data.hash }}";
      };
    };
    {%- endfor %}
  };

  # Build the node modules directory
  nodeModules = runCommand "node-modules" {
    nativeBuildInputs = [ 
      gnutar 
      makeWrapper
    ];
  } ''
    mkdir -p $out/node_modules/.bin

    # Extract a given package to it's destination
    extract() {
      local pkg=$1
      local dest=$2
      
      mkdir -p "$dest"
      tar -xzf "$pkg" -C "$dest" --strip-components=1
    }

    # Process each package
    ${lib.concatStringsSep "\n" (lib.mapAttrsToList (name: pkg: ''
      echo "Installing package ${name}..."

      mkdir -p "$out/node_modules/${pkg.out_path}"
      extract "${pkg.pkg}" "$out/node_modules/${pkg.out_path}"
      
      # Handle binaries if they exist
      ${lib.concatStringsSep "\n" (lib.mapAttrsToList (binName: binPath: ''
        ln -sf "${binPath}" "$out/node_modules/.bin/${binName}"
      '') pkg.binaries)}
    '') packages)}

    # Force bun instead of node for script execution
    makeWrapper ${bun}/bin/bun $out/bin/node
    export PATH="$out/bin:$PATH"

    patchShebangs $out/node_modules
  '';

in {
  inherit nodeModules packages;
}

